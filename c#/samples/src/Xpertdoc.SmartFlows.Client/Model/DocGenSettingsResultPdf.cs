/* 
 * Xpertdoc SmartFlows
 *
 * This describes the REST api for one Xpertdoc SmartFlows project
 *
 * OpenAPI spec version: 4.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = Xpertdoc.SmartFlows.Client.Client.SwaggerDateConverter;

namespace Xpertdoc.SmartFlows.Client.Model
{
    /// <summary>
    /// DocGenSettingsResultPdf
    /// </summary>
    [DataContract]
    public partial class DocGenSettingsResultPdf :  IEquatable<DocGenSettingsResultPdf>, IValidatableObject
    {
        /// <summary>
        /// Specifies the PDF standards compliance level. Pdf15: The output file will comply with the PDF 1.5 standard. PdfA1a: The output file will comply with the PDF/A-1a standard. This level includes all the requirements of PDF/A-1b and additionally requires that document structure be included (also known as being tagged), with the objective of ensuring that document content can be searched and repurposed. PdfA1b: The output file will comply with the PDF/A-1b standard. PDF/A-1b has the objective of ensuring reliable reproduction of the visual appearance of the document
        /// </summary>
        /// <value>Specifies the PDF standards compliance level. Pdf15: The output file will comply with the PDF 1.5 standard. PdfA1a: The output file will comply with the PDF/A-1a standard. This level includes all the requirements of PDF/A-1b and additionally requires that document structure be included (also known as being tagged), with the objective of ensuring that document content can be searched and repurposed. PdfA1b: The output file will comply with the PDF/A-1b standard. PDF/A-1b has the objective of ensuring reliable reproduction of the visual appearance of the document</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ComplianceEnum
        {
            
            /// <summary>
            /// Enum Pdf15 for "pdf15"
            /// </summary>
            [EnumMember(Value = "pdf15")]
            Pdf15,
            
            /// <summary>
            /// Enum PdfA1b for "pdfA1b"
            /// </summary>
            [EnumMember(Value = "pdfA1b")]
            PdfA1b,
            
            /// <summary>
            /// Enum PdfA1a for "pdfA1a"
            /// </summary>
            [EnumMember(Value = "pdfA1a")]
            PdfA1a
        }

        /// <summary>
        /// Controls how fonts are embedded into the resulting PDF documents. All: Embed all fonts. Non Standard: embed all fonts except standard Windows fonts Arial and Times New Roman. None: no fonts are embedded
        /// </summary>
        /// <value>Controls how fonts are embedded into the resulting PDF documents. All: Embed all fonts. Non Standard: embed all fonts except standard Windows fonts Arial and Times New Roman. None: no fonts are embedded</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum FontEmbeddingModeEnum
        {
            
            /// <summary>
            /// Enum All for "all"
            /// </summary>
            [EnumMember(Value = "all")]
            All,
            
            /// <summary>
            /// Enum NonStandard for "nonStandard"
            /// </summary>
            [EnumMember(Value = "nonStandard")]
            NonStandard,
            
            /// <summary>
            /// Enum None for "none"
            /// </summary>
            [EnumMember(Value = "none")]
            None
        }

        /// <summary>
        /// Specifies the PDF standards compliance level. Pdf15: The output file will comply with the PDF 1.5 standard. PdfA1a: The output file will comply with the PDF/A-1a standard. This level includes all the requirements of PDF/A-1b and additionally requires that document structure be included (also known as being tagged), with the objective of ensuring that document content can be searched and repurposed. PdfA1b: The output file will comply with the PDF/A-1b standard. PDF/A-1b has the objective of ensuring reliable reproduction of the visual appearance of the document
        /// </summary>
        /// <value>Specifies the PDF standards compliance level. Pdf15: The output file will comply with the PDF 1.5 standard. PdfA1a: The output file will comply with the PDF/A-1a standard. This level includes all the requirements of PDF/A-1b and additionally requires that document structure be included (also known as being tagged), with the objective of ensuring that document content can be searched and repurposed. PdfA1b: The output file will comply with the PDF/A-1b standard. PDF/A-1b has the objective of ensuring reliable reproduction of the visual appearance of the document</value>
        [DataMember(Name="compliance", EmitDefaultValue=false)]
        public ComplianceEnum? Compliance { get; set; }
        /// <summary>
        /// Controls how fonts are embedded into the resulting PDF documents. All: Embed all fonts. Non Standard: embed all fonts except standard Windows fonts Arial and Times New Roman. None: no fonts are embedded
        /// </summary>
        /// <value>Controls how fonts are embedded into the resulting PDF documents. All: Embed all fonts. Non Standard: embed all fonts except standard Windows fonts Arial and Times New Roman. None: no fonts are embedded</value>
        [DataMember(Name="fontEmbeddingMode", EmitDefaultValue=false)]
        public FontEmbeddingModeEnum? FontEmbeddingMode { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="DocGenSettingsResultPdf" /> class.
        /// </summary>
        /// <param name="Compliance">Specifies the PDF standards compliance level. Pdf15: The output file will comply with the PDF 1.5 standard. PdfA1a: The output file will comply with the PDF/A-1a standard. This level includes all the requirements of PDF/A-1b and additionally requires that document structure be included (also known as being tagged), with the objective of ensuring that document content can be searched and repurposed. PdfA1b: The output file will comply with the PDF/A-1b standard. PDF/A-1b has the objective of ensuring reliable reproduction of the visual appearance of the document (default to ComplianceEnum.Pdf15).</param>
        /// <param name="PreserveFormFields">Specifies whether to preserve form fields in PDF or convert them to text. Microsoft Word form fields include text input, drop down and check box controls. When set to false, these fields will be exported as text. When set to true, these fields will be exported as PDF form fields. When exporting form fields to PDF as form fields, some formatting loss might occur because PDF form fields do not support all features of Microsoft Word form fields (default to false).</param>
        /// <param name="FontEmbeddingMode">Controls how fonts are embedded into the resulting PDF documents. All: Embed all fonts. Non Standard: embed all fonts except standard Windows fonts Arial and Times New Roman. None: no fonts are embedded (default to FontEmbeddingModeEnum.None).</param>
        /// <param name="Encryption">Encryption.</param>
        public DocGenSettingsResultPdf(ComplianceEnum? Compliance = ComplianceEnum.Pdf15, bool? PreserveFormFields = false, FontEmbeddingModeEnum? FontEmbeddingMode = FontEmbeddingModeEnum.None, DocGenSettingsResultPdfEncryption Encryption = default(DocGenSettingsResultPdfEncryption))
        {
            // use default value if no "Compliance" provided
            if (Compliance == null)
            {
                this.Compliance = ComplianceEnum.Pdf15;
            }
            else
            {
                this.Compliance = Compliance;
            }
            // use default value if no "PreserveFormFields" provided
            if (PreserveFormFields == null)
            {
                this.PreserveFormFields = false;
            }
            else
            {
                this.PreserveFormFields = PreserveFormFields;
            }
            // use default value if no "FontEmbeddingMode" provided
            if (FontEmbeddingMode == null)
            {
                this.FontEmbeddingMode = FontEmbeddingModeEnum.None;
            }
            else
            {
                this.FontEmbeddingMode = FontEmbeddingMode;
            }
            this.Encryption = Encryption;
        }
        

        /// <summary>
        /// Specifies whether to preserve form fields in PDF or convert them to text. Microsoft Word form fields include text input, drop down and check box controls. When set to false, these fields will be exported as text. When set to true, these fields will be exported as PDF form fields. When exporting form fields to PDF as form fields, some formatting loss might occur because PDF form fields do not support all features of Microsoft Word form fields
        /// </summary>
        /// <value>Specifies whether to preserve form fields in PDF or convert them to text. Microsoft Word form fields include text input, drop down and check box controls. When set to false, these fields will be exported as text. When set to true, these fields will be exported as PDF form fields. When exporting form fields to PDF as form fields, some formatting loss might occur because PDF form fields do not support all features of Microsoft Word form fields</value>
        [DataMember(Name="preserveFormFields", EmitDefaultValue=false)]
        public bool? PreserveFormFields { get; set; }


        /// <summary>
        /// Gets or Sets Encryption
        /// </summary>
        [DataMember(Name="encryption", EmitDefaultValue=false)]
        public DocGenSettingsResultPdfEncryption Encryption { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class DocGenSettingsResultPdf {\n");
            sb.Append("  Compliance: ").Append(Compliance).Append("\n");
            sb.Append("  PreserveFormFields: ").Append(PreserveFormFields).Append("\n");
            sb.Append("  FontEmbeddingMode: ").Append(FontEmbeddingMode).Append("\n");
            sb.Append("  Encryption: ").Append(Encryption).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            return this.Equals(obj as DocGenSettingsResultPdf);
        }

        /// <summary>
        /// Returns true if DocGenSettingsResultPdf instances are equal
        /// </summary>
        /// <param name="other">Instance of DocGenSettingsResultPdf to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DocGenSettingsResultPdf other)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            if (other == null)
                return false;

            return 
                (
                    this.Compliance == other.Compliance ||
                    this.Compliance != null &&
                    this.Compliance.Equals(other.Compliance)
                ) && 
                (
                    this.PreserveFormFields == other.PreserveFormFields ||
                    this.PreserveFormFields != null &&
                    this.PreserveFormFields.Equals(other.PreserveFormFields)
                ) && 
                (
                    this.FontEmbeddingMode == other.FontEmbeddingMode ||
                    this.FontEmbeddingMode != null &&
                    this.FontEmbeddingMode.Equals(other.FontEmbeddingMode)
                ) && 
                (
                    this.Encryption == other.Encryption ||
                    this.Encryption != null &&
                    this.Encryption.Equals(other.Encryption)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            // credit: http://stackoverflow.com/a/263416/677735
            unchecked // Overflow is fine, just wrap
            {
                int hash = 41;
                // Suitable nullity checks etc, of course :)
                if (this.Compliance != null)
                    hash = hash * 59 + this.Compliance.GetHashCode();
                if (this.PreserveFormFields != null)
                    hash = hash * 59 + this.PreserveFormFields.GetHashCode();
                if (this.FontEmbeddingMode != null)
                    hash = hash * 59 + this.FontEmbeddingMode.GetHashCode();
                if (this.Encryption != null)
                    hash = hash * 59 + this.Encryption.GetHashCode();
                return hash;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
